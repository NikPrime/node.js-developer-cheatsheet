/*
Node.js - это среда выполнения JavaScript на сервере, построенная на движке V8, и позволяющая запускать JS на сервере


Устройство Node.js
  1. V8 - движок, выполняющий JS-код, и компилирующий его в машинный
  2. Libuv - библиотека, написанная на C, и обеспечивающая асинхронные операции ввода/вывода. Позволяет работать с файловой системой, сетевыми операциями и другими асинхронными задачами
  3. Core libraries - набор встроенных модулей (fs, http, events и другие)
  4. npm - менеджер пакетов. Позволяет работать со сторонними модулями и библиотеками
  5. Bindings - позволяет из JS работать с библиотеками и кодом C / C++
  6. Event loop - обеспечивает асинхронную обработку задач

Фазы Event loop:
  Ожидание синхронных операций и событий
  Проверка фазы
  1. Таймеры (setTimeout, setInterval)
  2. I / O коллбэки (Выполняются все колбеки кроме close, таймеров и setImmediate)
  3. Pending
  4. Poll (Получение новых событий ввода/вывода, нода может блокироваться)
  5. Check (Выполняются колбэки, заданные setImmediate)

Глобальные переменные:
global - аналог window для браузера
console - вызов консоли
performance - позволяет измерять производительность приложения
Buffer - набор байт, получаемый например при чтении файла
AbortController - позволяет прерывать promised based API

Таймеры:
setTimeout, clearTimeout
setInterval, clearInterval
setImmediate, clearImmediate - выполняется асинхронно, но как можно скорее

__dirname - путь до текущей папки
__filename - путь до текущей папки + имя файла с расширением
*/



// Perfomance - изменение производительности
performance.mark('start') // отметка
performance.measure(() => {}, 'start', 'end') // измерение между двумя отметками
performance.getEntries() // получение всех измерений



// Path - работа с путями к файлам и директориям в ОС
const path = require('path')
path.basename(__filename) // название файла
path.dirname(__filename) // имя директории, в которой находится файл
path.extname(__filename) // показывает расширение файла (например .js)
path.join(__dirname, 'server', 'index.html') // получаем абсолютный путь, склеивая аргументы



// Модуль fs (file system)
const fs = require('fs')
fs.mkdir(path.join('./'), (err) => {}) // создание новой папки, если существует - ошибка
fs.rmkdir(path.join('./')) // удаление папки
fs.writeFile('filePath', 'content') // создание нового файла
fs.appendFile('filePath', 'new_content') // дозапись / дополнение к файлу
fs.readFile('filePath', 'utf-8', (err, content) => {}) // чтение файла, если нет 2-го параметра - возвращает buffer
fs.watch('filePath') // отслеживает изменения файла
Buffer.from('content') // преобразует данные из буффера в нормальный вид



// Модуль os - позволяет получать информацию про ос, в которой находимся сейчас
const os = require('os')
os.platform() // название операционной системы
os.arch() // архитектура процессора
os.cpus() // получаем объект { model: модель процессора, speed: скорость, times: {user: ..., ... }
os.freemem() // сколько свободной памяти
os.totalmem() // сколько всего памяти
os.homedir() // базовая директория компьютера
os.uptime() // сколько времени включена система



// Модуль events - работа с событиями: создание и прослушивание событий
const EventEmitter = require('events')
class MyEmitter extends EventEmitter {}
const emitter = new MyEmitter()

myEmitter.on('connected', (data) => { // myEmitter.once(..) получит только одно событие, на остальные не реагирует
    console.log('Получил сообщение: ' + data)
})

emitter.emit('connected', data => console.log('Встретимся в 8:00'))



// Worker threads (поток, тред) - позволяют выполнять многозадачные операции в фоновом режиме
const { Worker } = require('worker_threads')
const worker = new Worker('./worker.js', { workerData: 'worker data' }) // создание нового потока

// в основном потоке
worker.postMessage()

// в worker thread
const { parentPort }  = require('worker_threads')
parentPort.on('message', (message) => {
    console.log(message); // { hello: 'world' }
})



/*
Child process - представляет возможность создания и управления дочерними процессами операционной системы из вашего приложения.
Это позволяет запускать внешние команды или программы и взаимодействовать с ними через ваше Node.js приложение
*/
const {
    exec, // Для выполнения команды в терминале с возможностью обработки вывода и ошибок
    spawn, // Для запуска нового процесса и прямой обработки потоков ввода/вывода
    fork // Для создания нового Node.js процесса. Дочерние процессы могут обмениваться сообщениями с главным процессом
} = require('child_process')

exec('ls -l', (error, stdout, stderr) => {
   console.log(error, stdout, stderr)
})

spawn('ls', ['-l'])

fork('./child.js')

/*
Worker threads и Child process используются для параллельной обработки задач, но делают это по-разному
Worker threads использует множество потоков внутри одного процесса
Child process использует множество отдельных процессов

Процесс - приложение, потоки - исполняемый участок кода внутри приложения (процесса)
*/



/*
Модуль stream - работа с потоками, эффективная обработка больших объемов данных. Обрабатываются по частям, не загружая всю информацию целиком
  1. Readable Stream (поток для чтения): Это источник данных, из которого можно читать информацию.
    Например, файл, HTTP запрос или генератор данных
  2. Writable Stream (поток для записи): Это назначение для данных, куда можно записывать информацию.
    Например, файл, HTTP ответ или цель для записи данных
  3. Duplex/Transform Streams (дуплексные/трансформирующие потоки): Потоки, которые одновременно являются потоками для чтения и записи.
    Они могут изменять или преобразовывать данные, которые проходят через них.
*/



/*
Операции, которые могут блокировать основной поток:
 1. Длительные операции ввода-вывода (Long I/O Operations): Например, чтение или запись больших файлов, запросы к медленным или перегруженным сетям могут заблокировать поток исполнения, если они выполняются в основном потоке
 2. Synchronous Operations: Использование синхронных версий методов вместо их асинхронных аналогов может блокировать поток. Например, readFileSync() вместо readFile()
 3. Операции, требующие больших вычислительных ресурсов: Некоторые вычислительно интенсивные операции могут также блокировать поток, особенно если они выполняются синхронно в основном потоке
*/
